% !TeX program = lualatex

\documentclass[
ngerman,
subtask=ruled %or plain
]{tudaexercise}

\usepackage[english, main=ngerman]{babel}
\usepackage[autostyle]{csquotes}

\usepackage{amsmath,amssymb}

\usepackage{float}

\usepackage{biblatex}
%\bibliography{DEMO-TUDaBibliography}

\newcommand{\dd}{\,\mathrm{d}}
\newcommand{\e}{\mathrm{e}}


\ConfigureHeadline{
	headline={HSI Übung - Niklas Beck und Paul Hollmann}
}

\begin{document}
	
	\title[Übung Hochleistungssimulationen]{Hochleistungssimulationen}
	\subtitle{\"Ubung 1}
	\author{Niklas Beck (2582775), Paul Hollmann (2465070)}
	\term{Wintersemester 2023/24}
	%\sheetnumber{1}
	\date{Abgabe 26. November 2023}
	\maketitle
	
	\hrule
	{\Large \textbf{Matrix-Vektor-Multiplikation}}
	\hrule
	
	Erklärung als eine Versuchsbeschreibung, Versuchsvorhaben und Arbeitsschritte
	
	\begin{task}{Sequentielle Berechnung des Matrix-Vektor-Produkts}
		Das Matrix-Vektor-Produkt ist eine wohl bekannte mathematische Operation, welche auch für große Matrizen gebraucht wird.
		Um die Rechenzeit möglichst gering zu halten, sind parallele Berechnungen sinnvoll zu wählen. Insbesondere wenn gleiche Operationen auf unterschiedlichen Daten ausgeführt werden sollen, ist dies ein gutes Einstiegsbeispiel zur Nutzung von OpenCL.
		
		Als sinnvoller erster Schritt brauchen wir ein sequentielles Programm.
		Eine kleine Eigenheit der hier verlangten Funktion ist die Eingabe nur eines Wertes $m$, welcher zur Initialisierung einer quadratischen Matrix und eines Vektors mit Zufallswerten genutzt wird. Wesentliches Ziel der Aufgabe ist es die Berechnungszeit zu untersuchen, weshalb konkrete Beispielmatrizen oder nicht-quadratische Beispiele wenig Mehrwert bieten.
		Ohne Vorgabe eines Datentyps haben wir uns für den Typ float entschieden, da er einen größeren Eingabemenge ermöglicht, aber nicht allzu viel Speicher braucht. Wäre die Präzision relevant, hätten wir uns eher für den double entschieden.
	\end{task}
	
	
	\begin{task}{Parallele Berechnung des Matrix-Vektor-Produkts}
		Noch bevor Bearbeitung der nächsten Teilaufgabe haben wir uns die Dokumentationen von OpenCL und JOCL herausgesucht und anhand der Beispiele aus dem moodle-Kurs und von JOCL ein Verständnis zur Einbindung von OpenCL-Code erlangt.
		Dann haben wir noch auf den eigenen Rechnern einen Kernel in einer Extradatei ausgelagert, da es eine schönere Formatierung ermöglicht.
		Dieser muss per BEFEHL in den JOCL Code eingefügt werden.
	\end{task}
	
	
	\begin{task}{Ausführung auf dem Lichtenberg-Hochleistungsrechner} 
		Zur Ausführung auf dem Cluster wird ein Job Script gebraucht.
		
	\end{task}

	\begin{task}{Messungen und Analyse} 
		In dieser Teilaufgabe ist verlangt für einige Problemgrößen die Ausführungszeit zu messen.
		
		\begin{tabular}{|c|c|c|}
			\hline
			Problemgröße $m$ & sequenzielle Abarbeitung & OpenCL - Parallelisierung \\
			\hline
			10 & 0.008070 ms & 0.788789 ms (0.326362 ms kernel time) \\
			\hline
			1000 & 11.542249 ms & 6.969872 ms (2.329117 ms kernel time) \\
			\hline
			2000 & 16.357809 ms & 18.217549 ms (6.386675 ms kernel time) \\
			\hline
			4000 & 37.825016 ms & 66.511173 ms (22.459137 ms kernel time) \\
			\hline
			8000 & 123.283086 ms & 247.282878 ms (78.444500 ms kernel time) \\
			\hline
			15000 & 409.209827 ms & 827.959536 ms (241.992205 ms kernel time) \\
			\hline
		\end{tabular}
	\end{task}

	\begin{task} {Variation der Anzahl der work-groups}
		Variieren Sie manuell die Größe und Anzahl der verwendeten work-groups (siehe oben local\_work\_size) und ermitteln
		Sie jeweils die Dauer der parallelen Abarbeitung bei einer konstanten Problemgröße n (m = 10000). Die Ausführung
		des parallelisierten Programms soll auf dem Lichtenberg-Hochleistungsrechner erfolgen. Dokumentieren Sie die zur
		Ausführung verwendete Hardware und relevante OpenCL Informationen (CL\_DEVICE\_MAX\_WORK\_GROUP\_SIZE etc.).
		Was ist zu beobachten und wie erklärt sich das Ergebnis?
	\end{task}

	
\end{document}